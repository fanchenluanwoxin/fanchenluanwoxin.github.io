<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java多线程实现和启动]]></title>
    <url>%2F2017%2F06%2F23%2Fthread-runnable%2F</url>
    <content type="text"><![CDATA[java 实现多线程有两种方式。一种继承 java.lang.Thread 类，重写父类的 run() 方法。另一种实现 java.lang.Runnable 接口，实现接口的 run() 方法。 Thread 与 Runnable Thread 用的是继承，java又是单继承，会有很大的极限性。Runnable 避免点继承的局限，一个类可以继承多个接口。 Runnable 同一个子类实列调用 new Thread(Runnable 实列).start() 适合于资源的共享。而 new Thread().run() 执行互补交互。 源码： public class Thread extends Object implements Runnable 由此可见 Thread 类也是 Runnable 接口的子类。 start() 方法与 run() 。 start() 方法是 Thread 类所有，但 Thread 累提供了接收 Runnable 实列的构造器，所以可以 new Thread(Runnable 实列).start()。 调用 start() 方法，会通过JVM找到 run() 方法。也就是在 start() 方法里面是有调用 run() 方法的。 通常做多线程使用的都是 Runnable 。 例子：1.继承 Threadpackage org.thread.demo;class MyThread extends Thread{ private String name; public MyThread(String name) { super(); this.name = name; } public void run(){ for(int i=0;i&lt;10;i++){ System.out.println(“线程开始：”+this.name+”,i=”+i); } }}package org.thread.demo;public class ThreadDemo01 { public static void main(String[] args) { MyThread mt1=new MyThread(“线程a”); MyThread mt2=new MyThread(“线程b”); mt1.run();//调用run方法启动线程 mt2.run(); }}package org.thread.demo;public class ThreadDemo01 { public static void main(String[] args) { MyThread mt1=new MyThread(“线程a”); MyThread mt2=new MyThread(“线程b”); mt1.start();//调用start方法启动线程 mt2.start(); }} 2.实现 Runnable 接口public interface Runnable{ public void run();}package org.runnable.demo;class MyThread implements Runnable{ private String name; public MyThread(String name) { this.name = name; } public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(“线程开始：”+this.name+”,i=”+i); } }} 3.Runnable 适合资源共享 买票事件为例package org.demo.dff;class MyThread extends Thread{private int ticket=10; public void run(){ for(int i=0;i0){ System.out.println(“卖票：ticket”+this.ticket–); } } }}package org.demo.dff;public class ThreadTicket {public static void main(String[] args) { MyThread mt1=new MyThread(); MyThread mt2=new MyThread(); MyThread mt3=new MyThread(); mt1.start();//每个线程都各卖了10张，共卖了30张票 mt2.start();//但实际只有10张票，每个线程都卖自己的票 mt3.start();//没有达到资源共享 }}package org.demo.runnable;public class RunnableTicket { public static void main(String[] args) { MyThread mt=new MyThread(); new Thread(mt).start();//同一个mt，但是在Thread中就不可以，如果用同一 new Thread(mt).start();//个实例化对象mt，就会出现异常 new Thread(mt).start(); }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[java内存模型]]></title>
    <url>%2F2017%2F06%2F22%2FJMM%2F</url>
    <content type="text"><![CDATA[java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。 关于并发在并发编程涉及到两个重要的问题：1.通信 2.线程 通信 线程之间的通信机制有两种 共享内存 和 消息传递。 共享内存 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。 消息传递 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是 wait() 和 notify()。 同步 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 volatile和synchronized synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主。 volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux 搭建gitlab]]></title>
    <url>%2F2017%2F06%2F20%2Fgitlab-install%2F</url>
    <content type="text"><![CDATA[其实最好的开发文档就是官方的开发文档，每次要搭建一个架构或者是学习一种新的的语言或者其它第一件事情就是找官方文档.所以gitlab https://about.gitlab.com/installation 官方文档。可以按着官方文档一步一步往下，如果出了错再去查找错误的解决方法。 我装的系统是centOS 5.6 安装配置依赖项 将在系统防火墙里面开放HTTP和SSH端口。如果你根本就没设置防火墙，或者没有限制那些端口可以跳过。 123456781.sudo yum install curl policycoreutils openssh-server openssh-clients2.sudo systemctl enable sshd3.sudo systemctl start sshd4.sudo yum install postfix5.sudo systemctl enable postfix6.sudo systemctl start postfix7.sudo firewall-cmd --permanent --add-service=http8.sudo systemctl reload firewalld 添加GitLab仓库,并安装到服务器上(这里是管道安装，还有其它的安装方式。比如rpm安装，下载源码编译安装等) 1curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bash 1sudo yum install gitlab-ce 上面没有报错的执行完了，你会发现 gitlab 就安装在/opt/gitlab 下面，配置文件在 /etc/gitlab 下面。还有3个全局脚本,主要用到的就是 gitlab-ctl。具体的参数可以 gitlab-ctl –help 查看。配置生效和启动 gitlab。 1sudo gitlab-ctl reconfigure 注意的是每次修改配置文件都要 gitlab-ctl reconfigure 配置才能生效。如果你自己有装nginx或者apace服务且端口用的是80，这样就会发生冲突。因为gitlab有内置nginx端口为80，只能修改端口了。 gitlab 用已有的nginx禁用内置nginxvim /etc/gitlab/gitlab.rb配置 nginx[‘enable’] = false然后配置生效 sudo gitlab-ctl reconfigure 给现有nginx增加一个虚拟主机 upstream gitlab { # gitlab socket 文件地址 # 7.x 版本在此位置 # server unix:/var/opt/gitlab/gitlab-rails/tmp/sockets/gitlab.socket; # 8.0 位置 server unix://var/opt/gitlab/gitlab-rails/sockets/gitlab.socket;} server { listen *:80; server_name gitlab.liaohuqiu.com; # 请修改为你的域名 server_tokens off; # don’t show the version number, a security best practice root /opt/gitlab/embedded/service/gitlab-rails/public; client_max_body_size 250m; access_log /var/log/gitlab/nginx/gitlab_access.log; error_log /var/log/gitlab/nginx/gitlab_error.log; location / { try_files $uri $uri/index.html $uri.html @gitlab; } location @gitlab { proxy_read_timeout 300; # Some requests take more than 30 seconds. proxy_connect_timeout 300; # Some requests take more than 30 seconds. proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Frame-Options SAMEORIGIN; proxy_pass http://gitlab; } 然后重启 nginx。 还有一个很重要的直接访问会报502，那是因为现有nginx没有访问 gitlab 用户的 socket 文件权限原因,于是简单粗暴的加上1sudo chmod -R o+x /var/opt/gitlab/gitlab-rails 每一次 reconfigure,gitlab 文件都会都会重新生成，所以每次 reconfigure 完，都要重新授权。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux 安装nginx]]></title>
    <url>%2F2017%2F06%2F20%2Finstall-nginx%2F</url>
    <content type="text"><![CDATA[##安装步骤 由于工作需要安装了好几次nginx，感觉好麻烦。于是就自己写了一个安装脚本，准备了安装材料。 版本nginx1.8.1 安装系统cent os下载地址 百度云 链接：http://pan.baidu.com/s/1hsnAcgW 密码：nvz3安装说明： 1.将下载的zip包放在 /usr底下，解压 1$ cd /usr 1$ uzip nginx1.8.1.zip 2.给脚本执行权限，执行脚本 1$ chmod u+x nginx-install.sh 1$ ./nginx-install.sh 等待安装完毕，nginx 就安装在了 /usr/local/nginx 里面。出了问题，解决然后重新跑。我自己安装是没有出现问题，执行的时候出现了问题就解决，然后重新跑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hellow Word !! hellow Blog !! hellow Hexo !!]]></content>
  </entry>
</search>