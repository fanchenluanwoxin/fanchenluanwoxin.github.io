<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM 内存模型]]></title>
    <url>%2F2017%2F06%2F28%2FJVM%2F</url>
    <content type="text"><![CDATA[内存划分分为6块，如下图。 1.程序计数器(Program Counter Register)- 程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。 - Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。 - 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2.java虚拟机栈(VM Stack)- java虚拟机栈是线程私有，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。 - 虚拟机执行java程序的时候，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。 - 栈帧又分为一下几个区域：局部变量表、操作数栈、动态连接、方法出口等。 - 平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在java虚拟机栈的局部变量表中。 - java的8中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。 当用户请求web服务器，每个请求开启一个线程负责用户的响应计算（每个线程分配一个虚拟机栈空间），如果并发量大时，可能会导致内存溢出（OutOfMemoneyError），可以适当的把每个虚拟机栈的大小适当调小一点，减少内存的使用量来提高系统的并发量。当栈空间调小以后，又会引发方法调用深度的的问题。因为，每个方法都会生成一个栈帧，如果方法调用深度很深就意味着，栈里面存放大量的栈帧，可能导致栈内存溢出（StackOverFlowError）。 3.本地方法栈(Native Method Stack) 本地方法栈 为虚拟机使用到本地方法服务（native）。本地方法栈为线程私有，功能和虚拟机栈非常类似。线程在调用本地方法时，来存储本地方法的局部变量表，本地方法的操作数栈等等信息。 本地方法：是非java语言实现的方法，例如，java调用C语言，来操作某些硬件信息 4.堆(Heap) 堆是被所有线程共享的区域，实在虚拟机启动时创建的。堆里面存放的都是对象的实例（new 出来的对象都存在堆中）。 - 我们平常所说的垃圾回收，主要回收的就是堆区。为了提升垃圾回收的性能，又把堆分成两块区新生代（young）和年老代（old），更细一点划分新生代又可划分为Eden区和2个Survivor区（From Survivor和To Survivor）。 Eden：新创建的对象存放在Eden区 From Survivor和To Survivor：保存新生代gc后还存活的对象。（使用复制算法，导致有一个Survivor空间浪费）Hotspot虚拟机新生代Eden和Survivor的大小比值为4：1，因为有两个Survivor，所以Eden:From Survivor:To Survivor比值为8：1：1。 老年代：对象存活时间比较长（经过多次新生代的垃圾收集，默认是15次）的对象则进入老年的。 当堆中分配的对象实例过多，且大部分对象都在使用，就会报内存溢出异常（OutOfMemoneyError）。如图结构： 5.方法区- 方法区是被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation） - 永久代也会垃圾回收，主要针对常量池回收，类型卸载（比如反射生成大量的临时使用的Class等信息）。 - 常量池用于存放编译期生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。 - 当方法区满时，无法在分配空间，就会抛出内存溢出的异常（OutOfMemoneyError）。 - java8中已经没有方法区了，取而代之的是元空间（Metaspace） 6.直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。 JDK1.4加的NIO中，ByteBuffer有个方法是allocateDirect(int capacity) ，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 原文：http://www.jianshu.com/p/a60d6ef0771b]]></content>
  </entry>
  <entry>
    <title><![CDATA[java多线程实现和启动]]></title>
    <url>%2F2017%2F06%2F23%2Fthread-runnable%2F</url>
    <content type="text"><![CDATA[java 实现多线程有两种方式。一种继承 java.lang.Thread 类，重写父类的 run() 方法。另一种实现 java.lang.Runnable 接口，实现接口的 run() 方法。 Thread 与 Runnable Thread 用的是继承，java又是单继承，会有很大的极限性。Runnable 避免点继承的局限，一个类可以继承多个接口。 Runnable 同一个子类实列调用 new Thread(Runnable 实列).start() 适合于资源的共享。而 new Thread().run() 执行互补交互。 源码： public class Thread extends Object implements Runnable 由此可见 Thread 类也是 Runnable 接口的子类。 start() 方法与 run() 。 start() 方法是 Thread 类所有，但 Thread 累提供了接收 Runnable 实列的构造器，所以可以 new Thread(Runnable 实列).start()。 调用 start() 方法，会通过JVM找到 run() 方法。也就是在 start() 方法里面是有调用 run() 方法的。 通常做多线程使用的都是 Runnable 。 例子：1.继承 Threadpackage org.thread.demo;class MyThread extends Thread{ private String name; public MyThread(String name) { super(); this.name = name; } public void run(){ for(int i=0;i&lt;10;i++){ System.out.println(“线程开始：”+this.name+”,i=”+i); } }} package org.thread.demo;public class ThreadDemo01 { public static void main(String[] args) { MyThread mt1=new MyThread(“线程a”); MyThread mt2=new MyThread(“线程b”); mt1.run();//调用run方法启动线程 mt2.run(); }} package org.thread.demo;public class ThreadDemo01 { public static void main(String[] args) { MyThread mt1=new MyThread(“线程a”); MyThread mt2=new MyThread(“线程b”); mt1.start();//调用start方法启动线程 mt2.start(); }} 2.实现 Runnable 接口public interface Runnable{ public void run();} package org.runnable.demo;class MyThread implements Runnable{ private String name; public MyThread(String name) { this.name = name; } public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(“线程开始：”+this.name+”,i=”+i); } }} 3.Runnable 适合资源共享 买票事件为例package org.demo.dff;class MyThread extends Thread{private int ticket=10; public void run(){ for(int i=0;i0){ System.out.println(“卖票：ticket”+this.ticket–); } } }} package org.demo.dff;public class ThreadTicket {public static void main(String[] args) { MyThread mt1=new MyThread(); MyThread mt2=new MyThread(); MyThread mt3=new MyThread(); mt1.start();//每个线程都各卖了10张，共卖了30张票 mt2.start();//但实际只有10张票，每个线程都卖自己的票 mt3.start();//没有达到资源共享 }} package org.demo.runnable;public class RunnableTicket { public static void main(String[] args) { MyThread mt=new MyThread(); new Thread(mt).start();//同一个mt，但是在Thread中就不可以，如果用同一 new Thread(mt).start();//个实例化对象mt，就会出现异常 new Thread(mt).start(); }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[java内存模型]]></title>
    <url>%2F2017%2F06%2F22%2FJMM%2F</url>
    <content type="text"><![CDATA[java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。 关于并发在并发编程涉及到两个重要的问题：1.通信 2.线程 通信 线程之间的通信机制有两种 共享内存 和 消息传递。 共享内存 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。 消息传递 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是 wait() 和 notify()。 同步 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 volatile和synchronized synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主。 volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux 搭建gitlab]]></title>
    <url>%2F2017%2F06%2F20%2Fgitlab-install%2F</url>
    <content type="text"><![CDATA[其实最好的开发文档就是官方的开发文档，每次要搭建一个架构或者是学习一种新的的语言或者其它第一件事情就是找官方文档.所以gitlab https://about.gitlab.com/installation 官方文档。可以按着官方文档一步一步往下，如果出了错再去查找错误的解决方法。 我装的系统是centOS 5.6 安装配置依赖项 将在系统防火墙里面开放HTTP和SSH端口。如果你根本就没设置防火墙，或者没有限制那些端口可以跳过。 123456781.sudo yum install curl policycoreutils openssh-server openssh-clients2.sudo systemctl enable sshd3.sudo systemctl start sshd4.sudo yum install postfix5.sudo systemctl enable postfix6.sudo systemctl start postfix7.sudo firewall-cmd --permanent --add-service=http8.sudo systemctl reload firewalld 添加GitLab仓库,并安装到服务器上(这里是管道安装，还有其它的安装方式。比如rpm安装，下载源码编译安装等) 1curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bash 1sudo yum install gitlab-ce 上面没有报错的执行完了，你会发现 gitlab 就安装在/opt/gitlab 下面，配置文件在 /etc/gitlab 下面。还有3个全局脚本,主要用到的就是 gitlab-ctl。具体的参数可以 gitlab-ctl –help 查看。配置生效和启动 gitlab。 1sudo gitlab-ctl reconfigure 注意的是每次修改配置文件都要 gitlab-ctl reconfigure 配置才能生效。如果你自己有装nginx或者apace服务且端口用的是80，这样就会发生冲突。因为gitlab有内置nginx端口为80，只能修改端口了。 gitlab 用已有的nginx禁用内置nginxvim /etc/gitlab/gitlab.rb配置 nginx[‘enable’] = false然后配置生效 sudo gitlab-ctl reconfigure 给现有nginx增加一个虚拟主机 upstream gitlab { # gitlab socket 文件地址 # 7.x 版本在此位置 # server unix:/var/opt/gitlab/gitlab-rails/tmp/sockets/gitlab.socket; # 8.0 位置 server unix://var/opt/gitlab/gitlab-rails/sockets/gitlab.socket;} server { listen *:80; server_name gitlab.liaohuqiu.com; # 请修改为你的域名 server_tokens off; # don’t show the version number, a security best practice root /opt/gitlab/embedded/service/gitlab-rails/public; client_max_body_size 250m; access_log /var/log/gitlab/nginx/gitlab_access.log; error_log /var/log/gitlab/nginx/gitlab_error.log; location / { try_files $uri $uri/index.html $uri.html @gitlab; } location @gitlab { proxy_read_timeout 300; # Some requests take more than 30 seconds. proxy_connect_timeout 300; # Some requests take more than 30 seconds. proxy_redirect off; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Frame-Options SAMEORIGIN; proxy_pass http://gitlab; } 然后重启 nginx。 还有一个很重要的直接访问会报502，那是因为现有nginx没有访问 gitlab 用户的 socket 文件权限原因,于是简单粗暴的加上1sudo chmod -R o+x /var/opt/gitlab/gitlab-rails 每一次 reconfigure,gitlab 文件都会都会重新生成，所以每次 reconfigure 完，都要重新授权。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux 安装nginx]]></title>
    <url>%2F2017%2F06%2F20%2Finstall-nginx%2F</url>
    <content type="text"><![CDATA[##安装步骤 由于工作需要安装了好几次nginx，感觉好麻烦。于是就自己写了一个安装脚本，准备了安装材料。 版本nginx1.8.1 安装系统cent os下载地址 百度云 链接：http://pan.baidu.com/s/1hsnAcgW 密码：nvz3安装说明： 1.将下载的zip包放在 /usr底下，解压 1$ cd /usr 1$ uzip nginx1.8.1.zip 2.给脚本执行权限，执行脚本 1$ chmod u+x nginx-install.sh 1$ ./nginx-install.sh 等待安装完毕，nginx 就安装在了 /usr/local/nginx 里面。出了问题，解决然后重新跑。我自己安装是没有出现问题，执行的时候出现了问题就解决，然后重新跑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hellow Word !! hellow Blog !! hellow Hexo !!]]></content>
  </entry>
</search>